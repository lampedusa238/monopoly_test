# monopoly_test

## Test

**Какой из запросов выведет данные в порядке сначала по убыванию значений col_1, затем по возрастанию значений col_2?**
- **`SELECT * FROM Table_1 ORDER BY col_1 DESC, col_2 ASC`**
- SELECT * FROM Table_1 ORDER BY col_1, col_2 DESC
- SELECT * FROM Table_1 ORDER BY col_1 , col_2
- SELECT * FROM Table_1 ORDER BY col_1, col_2 ASC

**Имеются две таблицы,Table_1иTable_2. Какой результат запроса выведет база данных?**
```sql
SELECT *  
FROM Table_1  
INNER JOIN Table_2  
ON Table_1.col_1 = Table_2.col_1  
```

- **`Вернет строки, где совпадают значения col_1 в Table_1 и Table_2.`**
- Вернет все строки из Table_1, дополненные строками из Table_2, даже если col_1 не совпадает.
- Вернет все строки из Table_2, дополненные строками из Table_1, даже если col_1 не совпадает.
- Вернет все строки из Table_1 и Table_2, независимо от совпадения col_1.

**Имеются две таблицы, Table_1 и Table_2. Какой результат запроса выведет база данных с соединением LEFT JOIN?**  
```sql
SELECT * 
FROM Table_1 
	LEFT JOIN Table_2 
		ON Table_1.col_1 = Table_2.col_1
```

- Вернет все строки из Table_1 и только совпадающие строки из Table_2.
- Вернет только строки, где совпадают значения col_1 в Table_1 и Table_2.ополненные строками из Table_2, даже если col_1 не совпадает.
- **`Вернет все строки из Table_1, независимо от наличия соответствий в Table_2, и NULL для отсутствующих строк Table_2.`**
- Вернет все строки из Table_2 и только совпадающие строки из Table_1.Table_2, независимо от совпадения col_1.

**Дана таблица table_2 (с единственным столбцом value (INTEGER)), состоящая из следующих 5 строк: [1, 2, 3, 4, 5]. Какой результат вернет запрос?**
```
SELECT (AVG(value) * COUNT(*)) - SUM(value)  
FROM table_2;
```

- 9
- 6
- NULL
- 3
- **`0`**

**Что выведет запрос?**
```sql
SELECT Col_1, Col_2, SUM(Col_3) AS Col_3
FROM Table_1  
WHERE Col_2 IS NOT NULL  
GROUP BY Col_1
```

- **`Таблицу из 3-х столбцов, отфильтрованную по столбцу Col_2, сгруппированную по столбцу Col_1, с суммой по столбцу Col_3`**
- Выведет пустой запрос, из-за указанной фильтрации
- Вывод будет зависеть от наполнения таблицы
- Запрос завершится ошибкой

**Какую очередность будет использовать обработчик при исполнении запроса?***
- SELECT, FROM, WHERE
- FROM, SELECT, WHERE
- WHERE, FROM, SELECT
- **`FROM, WHERE, SELECT`**

**Что вернет данный запрос?**
```sql
SELECT *  
FROM any_table  
WHERE parent_id = parent_id;  
```

 *parent_id может содержать null*

- Все записи
- **`Не все записи`**
- Запрос выведет ошибку

**Сколько строк вернет данный запрос?**
```sql
SELECT *  
FROM dba_users s  
WHERE s.USERNAME like '%'  
```

 *USERNAME не может содержать null*
 
- Ничего не вернет
- **`Все строки таблицы`**
- Все строки в который есть символ %
- Выдаст ошибку


**Данный запрос используется для:**
```
DELETE
FROM customers  
WHERE ctid NOT IN  
(SELECT max(ctid)  
FROM customers  
GROUP BY customers.*);
```

- **`Удаления дубликатов в таблице`**
- Нет правильного варианта
- Удаления max значения в ctid
- Какой результат вернет запрос?

**SELECT 3/2;**
- 1.5
- **`1`**
- Ошибка

**Сколько строк будет результатом этого запроса?**
```sql
SELECT 1
UNION ALL  
SELECT 1  
UNION  
SELECT 1
```

- 3
- 2
- **`1`**

**Имеется база данных интернет-магазина, таблицы:** 
	а) Покупатели – хранит информацию по клиентам (ФИО, логин, пароль и т.п.); 
	б) Заказы – содержит номер заказа, комментарий, дату доставки, покупателя (который сделал заказ) и т.д.; 
	в) Товары – id товара, наименование, цена, остатки и т.п.; 
	г) Заказанные товары – хранит информацию о заказанных товарах (заказ, товар, количество). Какой тип отношения между таблицами "Покупатели" и "Заказы"?

- Один к одному
- **`Один ко многим`**
- Многие ко многим
- Таблицы никак не связаны


**Чем различаются запросы ниже? **
```sql
Запрос №1  
SELECT COUNT(*) AS Cnt  
FROM Table_1  
  
Запрос №2  
SELECT COUNT(DISTINCT Col_1) AS Cnt  
FROM Table_1
``` 

- Результаты запросов всегда будут различаться на любом возможном содержании таблицы
- Результаты запросов не будут различаться на любом возможном содержании таблицы
- **`Запрос №1 вернет значение больше, чем запрос №2, если стоблец Col_1 будет содержать значения NULL для некоторых строк`**
- **`Запрос №1 вернет значение больше, чем запрос №2, если стоблец Col_1 будет содержать повторяющиеся значения для некоторых строк`**


**Какой из следующих кодов вернет список квадратов чисел от 0 до 9 включительно?**
- **squares = `[x*x for x in range(10)]`**
- squares = `map(lambda x: x*x, range(10))`
- **squares = `[x**2 for x in range(10)]`**
- **squares = `list(x*x for x in range(10))**
`

**Что вернет данный код?**
``` python
import pandas as pd

df = pd.DataFrame({  
  'A': [1, 2, 3, 4],  
  'B': [5, 6, 7, 8]  
})  
df['C'] = df['A'] + df['B']
```

- **`Создаст новую колонку 'C' со значениями [6, 8, 10, 12]`**
- Создаст новую колонку 'C' со значениями [1, 2, 3, 4, 5, 6, 7, 8]
- Создаст новую колонку 'C' со значениями [5, 6, 7, 8]
- Создаст новую колонку 'C' со значениями [10, 20, 30, 40]


**Какое значение будет у переменной 'result' после выполнения следующего кода?**
```
data = [1, 2, 3, 4, 5]

result = sum(x * 2 for x in data if x > 3)
```

- 0
- **`18`**
- 14
- 20

**Что напечатает следующий код?**
```Python
def func(a, b=[]):  
  b.append(a)  
  return b  
  
print(func(1))  
print(func(2))  
print(func(3))
```

- [1], [2], [3]
- **`[1], [1, 2], [1, 2, 3]`**
- [1, 2, 3], [1, 2, 3], [1, 2, 3]
- Ошибка


**Какой тип задачи используется для выполнения Python-кода в DAG Airflow?**
- BashOperator
- **`PythonOperator`**
- DummyOperator
- BranchPythonOperator


## Task1

**Необходимо разработать DAG для Apache Airflow, который будет загружать данные о погоде из публичного API, обрабатывать их и сохранять в базу данных. Кроме того, вам нужно будет настроить Git-репозиторий для отслеживания изменений в коде.**

Для этой задачи мы будем использовать публичный API OpenWeatherMap для получения данных о погоде. API предоставляет информацию о текущей погоде, прогнозе и исторических данных. 

Пример запроса к API:
GET [http://api.openweathermap.org/data/2.5/weather?q=London&appid=YOUR_API_KEY](http://api.openweathermap.org/data/2.5/weather?q=London&appid=YOUR_API_KEY)

Необходимые шаги:
 - Загрузка данных о погоде из API OpenWeatherMap.Пример запроса: http://api.openweathermap.org/data/2.5/weather?q=London&appid=YOUR_API_KEY.Сохранение данных в локальный файл /tmp/weather_data.json.  
-  Загрузка данных из локального файла /tmp/weather_data.json в DataFrame.
- Обработка данных: преобразование температур из Кельвинов в Цельсии. 
- Сохранение обработанных данных в файл processed_weather_data.csv
- Загрузка обработанных данных из processed_weather_data.csv
- Сохранение данных в файл  weather.parquet

**Настройка Git-репозитория**:

Инициализируйте новый Git-репозиторий.
Создайте основные ветки: main и develop.
Создайте ветку feature/add-dag от ветки develop для работы над вашим DAG.

**Разработка DAG в Airflow**:

 Создайте DAG с именем weather_data_pipeline_dag.DAG должен выполняться ежедневно в полночь.
 DAG должен состоять из следующих задач:
	 **Download Data**: загрузка данных о погоде из API OpenWeatherMap.
	 **Process Data**: очистка и преобразование загруженных данных.
	 **Save Data**: сохранение обработанных данных в файл parquet

**Использование Git**:

Добавьте ваш DAG в репозиторий и сделайте коммит с сообщением Add initial DAG for weather data pipeline.
Создайте pull request (PR) из ветки feature/add-dag в develop.
Объедините PR после проверки и одобрения.  

Ваше решение должно включать код для DAG в Airflow, а также команды Git для создания и управления репозиторием. Комментарии в коде приветствуются.  



## Task 2

Вам предоставлены данные о транзакциях интернет-магазина. Необходимо провести анализ данных и ответить на несколько вопросов, а также подготовить данные для дальнейшего использования. Для выполнения задачи используйте язык программирования Python и библиотеки для работы с данными, такие как Pandas и NumPy.

Вам предоставлен CSV-файл transactions.csv со следующей структурой:

| transaction_id | customer_id | product_id | **product_category** | **amount** | date       |
| -------------- | ----------- | ---------- | -------------------- | ---------- | ---------- |
| 1<br>          | 1001<br>    | 2001<br>   | Electronics<br>      | 299.99<br> | 2024-01-01 |
| 2<br>          | 1002<br>    | 2002<br>   | Clothing<br>         | 49.99<br>  | 2024-01-02 |
| 3<br>          | 1001<br>    | 2003<br>   | Electronics<br>      | 199.99<br> | 2024-01-03 |
| ...            | ...         | ...        | ...                  | ...        | ...        |



**Загрузка данных**: 
Загрузите данные из файла transactions.csv в DataFrame. 

**Предварительная обработка данных**: 
Проверьте данные на наличие пропущенных значений и обработайте их. 
Преобразуйте столбец date в формат datetime.  

**Анализ данных**: 
Вычислите общее количество транзакций. 
Определите общее количество уникальных клиентов. 
Найдите топ-5 категорий продуктов по общему доходу. 
Вычислите среднюю сумму транзакции по каждой категории продуктов.

**Визуализация данных**: 
Постройте гистограмму, показывающую распределение количества транзакций по месяцам. Постройте круговую диаграмму, показывающую долю дохода по категориям продуктов.  

**Подготовка данных для машинного обучения**: 
Создайте новый столбец year_month, содержащий год и месяц транзакции. 
Подготовьте сводную таблицу, показывающую общий доход по каждому клиенту для каждого месяца. 
Сохраните сводную таблицу в новый CSV-файл monthly_revenue_per_customer.csv.  

Ваше решение должно включать код на Python, который выполняет все вышеописанные шаги.Комментарии в коде приветствуются для пояснения ваших действий.